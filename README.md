# Программа сортировки слов текста
Программная функция выполняет сортировку слов в тексте.
## Параметры сортировки
  * Программа сортирует текст из символов латинского алфавита («abcdefghijklmnopqrstuvwxyz1234567890») 
  * Сортировка осуществляется относительно длины слова
  * Числа не учитываются
  * Слова сортируются в порядке убывания 
  * Программа использует алгоритм [сортировки вставками](https://youtu.be/a4IQKxDyR6s)
___
## Параметры входных и выходных данных
На вход программа принимает название текстового файла формата .txt или путь к этому файлу. 

В результате выполнения программной функции создаются 2 выходных файла.

Первый файл содержит отсортированный список слов(каждое с новой строки)
![Пример файла отсортированных слов](https://github.com/pasoffy/practice_suai/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(320).png)

_пример файла отсортированных слов_

Во втором файле можно найти анализ исходного текста: 
* количество слов каждой длины
* праметры сортировки
* первоначальный текст
* количество слов в первоначальном тексте
* время сортировки

 ![Пример файла с анализом слов](https://github.com/pasoffy/practice_suai/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(321).png)

_пример файла с анализом слов_
___
## Описание программной функции
В начале работы программа считывает название файла или путь к нему с консоли и с помощью отдельной функции check_file() проверяет, может ли файл быть открыт для дальнейшей работы.
```
 def check_file(name):
    try:
        if os.path.getsize(name) > 0:        # возвращает размер файла в байтах
           return True
        else:
            print("Это пустой файл")
            return False

    except OSError:                        # обработка исключения (файла с заданным именем не существует)
        print("Невозможно открыть файл!")
        return False
```
При успешном прохождении проверки программа открывает файл для работы над ним. Далее происходит следующая проверка: необходимо узнать, содержится ли в файле какой-либо текст, так как в противном случае сортировать попусту нечего. За эту проверку отвечает функция is_it_empty().
```
def is_it_empty(file):
    file.seek(0)
    for line in file:
        if line != '\n' and line != '':                   # проверка на то, есть ли в файле текст
            return True
    return False
```
Убедившись, что файл содержит текстовую информацию, программа с помощью отдельной функции word_division() делит текст на слова, которые попадают в массив. Таким образом, при завершении выполнения word_division() мы имеем массив, длина которого равна количеству слов в исходном тексте. После этого программа выводит на консоль информацию о параметрах индивидуального варианта, исходный текст, переданный через файл, и количество слов в нем. 
```
def word_division(file, words):
    input_file.seek(0)                  # устанавливаем курсор в начало файла
    for line in file:
        words.extend(line.strip().split())    # разбиваем текст на слова, которые записываем в массив
```
Поскольку в задании сказано о том, что символы и знаки не должны учитываться, необходимо произвести обработку полученных слов. Поэтому следующий шаг алгоритма – вызов отдельной функции updating_words(). После этого мы получаем массив слов без знаков препинания и, к тому же, без цифр, поскольку один из параметров индивидуального варианта – игнорирование чисел.
```
def updating_words(words):
    for i in range(len(words)):
        word = words.pop(i)
        new_word = ''
        for char in word:
            if char in string.punctuation or char in string.digits:
                continue                   # удаляем знаки препинания и цифры
            else:
                new_word += char
        words.insert(i, new_word)
    return words
```
После того, как все слова обработаны, можно переходить непосредственно к сортировке, которая так же вынесена в одноименную функцию insert_sort(). Согласно индивидуальному заданию, сортировку необходимо осуществить в обратном порядке, поэтому функция insert_sort() сортирует массив таким образом, чтобы он начинался с самого длинного слова (длина – еще один параметр индивидуального задания).

![Блок-схема алгоритма сортировки вставками](https://github.com/pasoffy/practice_suai/blob/main/diagram%20(24).png)

Когда сортировка осуществлена, алгоритм записывает отсортированный массив построчно в выходной файл. После алгоритм проверяет этот файл и, если в результате вывода он остается пустым, в него записывается сообщение о том, что сортировать просто нечего.
Затем алгоритм формирует словарь, ключами которого являются длины слов, а соответствующими значениями количества слов каждой длины. На основе этого словаря далее формируется список строк. Эти операции осуществляются благодаря отдельным функциям – make_analysis() и make_analysis_list().
```
def make_analysis(words):                                       # функция создания словаря, ключами которого являются
    data = {}                                                   # длины слов, а значениями количество слов
    for word in words:                                          # соответсвующей длины
        data[len(word)] = data.get(len(word), 0) + 1            # при обращении к несуществующему ключу, метод get()
    return data                                                 # возвращает значение переданное в качестве второго
                                                                # аргумента


def make_analysis_list(dictionary):                            # записываем значения из словаря в строки, которые
    array = []                                                 # в свою очередь добавляем в массив для последующей
    for key, value in dictionary.items():                      # записи в файл
        s = ''
        if key == 0:
            continue
        else:
            s = 'Количество слов, длина которых равна ' + str(key) + ' символов: ' + str(value)
            array.append(s)
    return array
```
После этого происходит запись анализа в отдельный файл и на консоль. 
![](https://github.com/pasoffy/practice_suai/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(314).png)


